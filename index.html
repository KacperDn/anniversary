<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>Kocham Cię ❤️</title>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
      touch-action: manipulation;
    }

    #hint {
      position: fixed;
      bottom: 40px;
      width: 100%;
      text-align: center;
      color: white;
      opacity: 0.6;
      font-size: 14px;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      pointer-events: none;
    }
  </style>
  <!-- Elegant fonts for the anniversary text -->
  <link href="https://fonts.googleapis.com/css?family=Great+Vibes:400&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Dancing+Script:700&display=swap" rel="stylesheet">
</head>
<body>

<div id="hint">Dotknij serca ❤️</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script>
  /**
   * Anniversary 3D Scene
   * 
   * Features:
   * - 3D heart as the main object, gently pulsing and rotating
   * - Animated "Kocham Cię ❤️" text, appearing letter by letter in an elegant font
   * - Floating small hearts in the background, moving across the whole screen
   * - Responsive design for mobile and desktop
   * 
   * Interactions:
   * - Animation starts on first touch or click (removes the hint, starts text animation and heart pulse)
   */

  let started = false;

  // Scene setup
  const scene = new THREE.Scene();

  // Perspective camera for a natural 3D look
  const camera = new THREE.PerspectiveCamera(
    60,
    window.innerWidth / window.innerHeight,
    0.1,
    100
  );
  camera.position.z = 6;

  // WebGL renderer with antialiasing and low-power preference
  const renderer = new THREE.WebGLRenderer({
    antialias: true,
    powerPreference: "low-power"
  });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Lighting: ambient and point light for soft, romantic effect
  scene.add(new THREE.AmbientLight(0xffffff, 0.6));
  const light = new THREE.PointLight(0xff6699, 1);
  light.position.set(5, 5, 5);
  scene.add(light);

  /**
   * Main 3D heart mesh
   * Custom shape using bezier curves for a classic heart look
   */
  const heartShape = new THREE.Shape();
  heartShape.moveTo(0, 0.4);
  heartShape.bezierCurveTo(0, 0.4, -1.2, -1.1, -2, 0.4);
  heartShape.bezierCurveTo(-2.8, 1.5, -1.4, 3.2, 0, 4);
  heartShape.bezierCurveTo(1.4, 3.2, 2.8, 1.5, 2, 0.4);
  heartShape.bezierCurveTo(1.2, -1.1, 0, 0.4, 0, 0.4);

  const heartGeometry = new THREE.ExtrudeGeometry(heartShape, {
    depth: 0.8,
    bevelEnabled: true,
    bevelThickness: 0.15,
    bevelSize: 0.15,
    bevelSegments: 3
  });

  const heartMaterial = new THREE.MeshStandardMaterial({
    color: 0xff3355,
    metalness: 0.3,
    roughness: 0.4
  });

  const heart = new THREE.Mesh(heartGeometry, heartMaterial);
  heart.scale.set(0.35, 0.35, 0.35);
  heart.rotation.x = Math.PI;
  heart.position.y = 0.7;
  scene.add(heart);

  // Soft glow behind the heart (not attached to the heart, just in the background)
  const glowCanvas = document.createElement("canvas");
  glowCanvas.width = 512;
  glowCanvas.height = 512;
  const glowCtx = glowCanvas.getContext("2d");
  const gradient = glowCtx.createRadialGradient(
    256, 256, 60, 256, 256, 240
  );
  gradient.addColorStop(0, "rgba(255,102,153,0.45)");
  gradient.addColorStop(0.5, "rgba(255,102,153,0.18)");
  gradient.addColorStop(1, "rgba(255,102,153,0)");
  glowCtx.fillStyle = gradient;
  glowCtx.beginPath();
  glowCtx.arc(256, 256, 240, 0, 2 * Math.PI);
  glowCtx.fill();

  const glowTexture = new THREE.CanvasTexture(glowCanvas);
  const glowMaterial = new THREE.SpriteMaterial({
    map: glowTexture,
    transparent: true,
    depthWrite: false,
  });
  const glowSprite = new THREE.Sprite(glowMaterial);
  glowSprite.scale.set(3.2, 3.2, 1);
  glowSprite.position.set(0, 0.7, -0.5);    
  scene.add(glowSprite);

  /**
   * Creates a text sprite using canvas and elegant fonts.
   * Used for the animated "Kocham Cię ❤️" message.
   * @param {string} text - Text to render
   * @returns {THREE.Sprite}
   */
  function createTextSprite(text) {
    const canvas = document.createElement("canvas");
    canvas.width = 1024;
    canvas.height = 256;

    const ctx = canvas.getContext("2d");
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    ctx.font = "bold 80px 'Great Vibes', 'Dancing Script', 'Times New Roman', serif";
    ctx.fillStyle = "white";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(text, canvas.width / 2, canvas.height / 2);

    const texture = new THREE.CanvasTexture(canvas);
    const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
    const sprite = new THREE.Sprite(material);

    sprite.scale.set(2.2, 0.7, 1);
    sprite.position.y = -1.8;

    // Store references for dynamic updates
    sprite._canvas = canvas;
    sprite._ctx = ctx;
    sprite._texture = texture;

    return sprite;
  }


  /**
   * Animated typewriter effect for the main message and personalized name.
   * Reveals the text letter by letter.
   */
  const fullText = "Kocham Cię ❤️";
  const nameText = "Dla Łucji";
  let currentText = "";
  let currentName = "";

  // Sprite for the name (above main text)
  function createNameSprite(text) {
    const canvas = document.createElement("canvas");
    canvas.width = 1024;
    canvas.height = 180;
    const ctx = canvas.getContext("2d");
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.font = "bold 100px 'Dancing Script', 'Great Vibes', 'Times New Roman', serif";
    ctx.fillStyle = "#ffb6e6";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(text, canvas.width / 2, canvas.height / 2);
    const texture = new THREE.CanvasTexture(canvas);
    const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
    const sprite = new THREE.Sprite(material);
    sprite.scale.set(2.2, 0.5, 1);
    sprite.position.y = -1.1;
    sprite._canvas = canvas;
    sprite._ctx = ctx;
    sprite._texture = texture;
    return sprite;
  }

  let nameSprite = createNameSprite("");
  scene.add(nameSprite);

  // Sprite for the main text
  let textSprite = createTextSprite("");
  scene.add(textSprite);

  // Animate name first, then main text
  function animateNameLetterByLetter(index = 0) {
    if (index > nameText.length) {
      setTimeout(() => animateTextLetterByLetter(1), 400);
      return;
    }
    currentName = nameText.slice(0, index);
    const ctx = nameSprite._ctx;
    ctx.clearRect(0, 0, nameSprite._canvas.width, nameSprite._canvas.height);
    ctx.font = "bold 100px 'Dancing Script', 'Great Vibes', 'Times New Roman', serif";
    ctx.fillStyle = "#ffb6e6";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(currentName, nameSprite._canvas.width / 2, nameSprite._canvas.height / 2);
    nameSprite._texture.needsUpdate = true;
    setTimeout(() => animateNameLetterByLetter(index + 1), 80);
  }

  function animateTextLetterByLetter(index = 0) {
    if (index > fullText.length) return;
    currentText = fullText.slice(0, index);
    const ctx = textSprite._ctx;
    ctx.clearRect(0, 0, textSprite._canvas.width, textSprite._canvas.height);
    ctx.font = "bold 140px 'Great Vibes', 'Dancing Script', 'Times New Roman', serif";
    ctx.fillStyle = "white";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(currentText, textSprite._canvas.width / 2, textSprite._canvas.height / 2);
    textSprite._texture.needsUpdate = true;
    setTimeout(() => animateTextLetterByLetter(index + 1), 90);
  }

  /**
   * Starts the animation on first user interaction.
   * Hides the hint and triggers the typewriter effect.
   */
  window.addEventListener("touchstart", start, { once: true });
  window.addEventListener("click", start, { once: true });

  function start() {
    started = true;
    document.getElementById("hint").style.display = "none";
    animateNameLetterByLetter(1);
  }

  /**
   * Floating background hearts
   * Creates multiple small hearts that float upwards and sway gently.
   */
  const flyingHearts = [];
  const heartCount = 40;

  for (let i = 0; i < heartCount; i++) {
    const shape = new THREE.Shape();
    shape.moveTo(0, 0.1);
    shape.bezierCurveTo(0, 0.1, -0.12, -0.11, -0.2, 0.1);
    shape.bezierCurveTo(-0.28, 0.15, -0.14, 0.32, 0, 0.4);
    shape.bezierCurveTo(0.14, 0.32, 0.28, 0.15, 0.2, 0.1);
    shape.bezierCurveTo(0.12, -0.11, 0, 0.1, 0, 0.1);

    const geometry = new THREE.ExtrudeGeometry(shape, {
      depth: 0.05,
      bevelEnabled: false
    });

    const material = new THREE.MeshStandardMaterial({
      color: 0xff99bb,
      metalness: 0.1,
      roughness: 0.7,
      transparent: true,
      opacity: 0.7
    });

    const mesh = new THREE.Mesh(geometry, material);
    mesh.position.x = (Math.random() - 0.5) * 12;
    mesh.position.y = Math.random() * 10 - 3;
    mesh.position.z = -2 - Math.random() * 2;
    mesh.rotation.z = Math.random() * Math.PI * 2;
    mesh.scale.setScalar(0.4 + Math.random() * 0.8);

    scene.add(mesh);
    flyingHearts.push({
      mesh,
      speed: 0.004 + Math.random() * 0.012,
      sway: 0.5 + Math.random() * 1.2,
      swaySpeed: 0.5 + Math.random()
    });
  }

  /**
   * Main animation loop.
   * Handles heart pulsing, rotation, text sprite animation, and floating hearts.
   */
  let t = 0;
  function animate() {
    requestAnimationFrame(animate);

    if (started) {
      t += 0.03;

      const pulse = 1 + Math.sin(t * 2) * 0.04;
      heart.scale.set(0.35 * pulse, 0.35 * pulse, 0.35 * pulse);


      heart.rotation.y = Math.sin(t) * 0.38; 
      heart.rotation.x = Math.PI + Math.sin(t * 0.7) * 0.18; 

      textSprite.rotation.z += 0.01;
      nameSprite.rotation.z -= 0.005;

      flyingHearts.forEach((h, i) => {
        h.mesh.position.y += h.speed;
        h.mesh.position.x += Math.sin(t * h.swaySpeed + i) * 0.01 * h.sway;
        h.mesh.rotation.z += 0.01 * (i % 2 === 0 ? 1 : -1);
        if (h.mesh.position.y > 6) {
          h.mesh.position.y = -4;
          h.mesh.position.x = (Math.random() - 0.5) * 12;
        }
      });
    }

    renderer.render(scene, camera);
  }

  animate();

  /**
   * Responsive resize handler.
   * Keeps the scene fitting the window on any device.
   */
  window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>

</body>
</html>
